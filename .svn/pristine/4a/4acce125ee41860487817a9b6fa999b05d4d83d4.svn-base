unit EvaluateUserResponseUnit;

/* ********************************************************** */
/* ********************************************************** */

void fUpdateOutgoingIncomingSMS(Client c, OutgoingSMS og, IncomingSMS ic, string st, int code){
    if(code==1){ og.responseText = ic.smsTextClean; }

    // Save outgoingSMS
    og.status = st; og.save();          

    // Save incomingSMS
    ic.incomingSMSID = og.dateTimeStamp; ic.status = st; ic.save();

    if(code==1){ fSaveOutgoingSMSLog(c, og, ic); }

    return null;
}

/* ********************************************************** */
/* ********************************************************** */

void fEvaluateUserResponse(Client c, Pattern p, CurrentSMSPattern cSMS , PatternType pT) {

    /* ****************************************************************************** */
    /* Get last : Message, IncomingSMS, OutgoingSMS and Topic for a particular client */
    /* ****************************************************************************** */

    Message[] mSs = cSMS.currentSMSPattern_MessageSetup; 
        mSs.sortAsc("dateTimeStamp"); 
        Message m = mSs.last();
	
    IncomingSMS[] iSs = IncomingSMS:relationshipIn(incomingSMS_clientNumber, c); 
        iSs.sortAsc("dateTimeStamp"); 
        IncomingSMS iS = iSs.last();

    OutgoingSMS[] oSs = OutgoingSMS:relationshipIn(outgoingSMS_client, c); 
        oSs.sortAsc("dateTimeStamp"); 
        OutgoingSMS oS = oSs.last();

    Topic t = uGetCurrentSchedule:fGetCurrentTopic(c); if(t==null){ return null; }
    int tt = t.topicType; if(tt==null){ tt=0; }
 
    /* ***************************************************************************** */
     /* Assign Variables for later use */
     /* ***************************************************************************** */

    bool bCorrectAnswer = false; bool bSendCorrectMessage = false; int ci = -2; string pmtns = ""; int endOnJump = 0; 
    int iMaxMMC = m.maxMultipleChoice;
    string sRightAnswer = m.correctAnswer;
    string sSMSText = iS.smsTextClean;

    /* ***************************************************************************** */
    /* Assume a valid MCR - unless this needs to be checked first */
    /* ***************************************************************************** */

    bool bDoValidMCRCheck = false;
    if(pT.RespValMCR==1 && iMaxMMC>0){ bDoValidMCRCheck = true; }

    bool bIsValidMCR = true;
    if( bDoValidMCRCheck==true ){ bIsValidMCR = BLUnits:validValue(sSMSText, iMaxMMC); }

    /* ***************************************************************************** */
    /* Log the event to ensure full visibility */
    string logstring = String:concat("Client='", c,"' | ResponseSMS= '", sSMSText,"' | IncomingSMS='", iS,"' | OutgoingSMS='", oS,"'"); Mez:log(logstring);
    /* ***************************************************************************** */
    
    /* Proceed if a valid multiple choice response has been received - or if not checking for multiple choice range */
	if( bIsValidMCR == true || bDoValidMCRCheck == false ) {
        
        /* Assume we should not check the response against a stored value */
        bool bDoNotCheckAnswer = true;

        /* Check the data if... */
        if( pT.RespValASV==1 ){                                  // RespValASV must be 1... forcing a check against stored value... And
            if( pT.RespValMCR==0 || bDoValidMCRCheck==true ){    // RespValMCR = 0 OR (RespValMCR = 1 and MaxMultipleChoice > 0)
                bDoNotCheckAnswer = false;
            }
        }
        
        /* If the answer needs to be validated, then validate the answer */
        if (bDoNotCheckAnswer == false){
            ci = fGetMatchingAnswer(sSMSText, sRightAnswer);
            if (ci >= -1){
                bCorrectAnswer = true;
                pmtns = fGetPatternMessageTextNext(ci, sRightAnswer, p);
            }
        }

        /* Check in Skip Logic for a possible Message_To match... Set CorrectAnswer to True if found */
        if(pmtns==""){
            pmtns = JumpToLogic:fGetJumpToMessageStringFromSource(sSMSText, m, c);
            if(pmtns!=""){
            	if(tt==6&&iMaxMMC<=1){
            		bDoNotCheckAnswer = true;
            	} else{
                	bCorrectAnswer = true;
                }
            }
        }

        /* The default option - status is simply completed. */
        string sStatusUpdateStr = "99";                                                                                     // 99 = Completed
        
        /* If answer either is correct or it does not need to be checked. */
		if( bCorrectAnswer==true ||  bDoNotCheckAnswer==true ) {

            /* In this if section, the status is either "not checked" or obviously "correct" */
            if(bDoNotCheckAnswer==true){ 
                sStatusUpdateStr = "92";                                                                                     // 92 = No Validation
            } else if(bCorrectAnswer==true){
                    sStatusUpdateStr = "100";                                                                                // 100 = Correct Answer

                    oS.userScore = JumpToLogic:fGetJumpToMessageStringScoreCorrect(sSMSText, m, c, tt);
                    sStatusUpdateStr = JumpToLogic:fGetJumpToStatusStringScoreCorrect(sSMSText, m, c, tt, sStatusUpdateStr);

                    if(pT.informNext == 1){ bSendCorrectMessage = true; }      
            }               

            /* Apply status to Outgoing and Incoming SMS tables. */
            fUpdateOutgoingIncomingSMS(c, oS, iS, sStatusUpdateStr, 1);

            /* Check to see whether to jump now? */
            endOnJump = NewFlowControllers:fCheckEndOnJump(sSMSText, m, c, 1);
            if(endOnJump==1){ fResetCSMSP(cSMS); return null; }

            /* Send confirmation of correct message */
            if(bSendCorrectMessage==true){ FixMessageList:sendFixedMessage(c, "6" , m.informCorrectText); }

            /* End pattern if it is to end on correct. */
            if(pT.StopPatternOnCorrect == 1) { 
                
                /* End pattern if it is to end on correct. */
                fResetCSMSP(cSMS);
                PatternList:endSMSPattern(c, p);
                    
    		} else {
                    
                /* Move on to the next message. */
                PatternList:sendNextSMS(c, p, pmtns);
                       
            }

		} else {
            /* In this part of the "if" section - the answer is obviously not "correct" but it was checked. */

            /* Add score adjustment (if so configured) based on incorrect answer */
            oS.userScore = JumpToLogic:fGetJumpToMessageStringScoreInCorrect(sSMSText, m, c);

            /* Check to see whether to jump now? */
            endOnJump = NewFlowControllers:fCheckEndOnJump(sSMSText, m, c, -1);

            /* Inform the client to redo. */
            if(pT.infoRedo == 1) {
                    
                sStatusUpdateStr = "31";                                                                    // 31 = Informed to Redo
                fUpdateOutgoingIncomingSMS(c, oS, iS, sStatusUpdateStr, 0);   

                if(endOnJump==1){ fResetCSMSP(cSMS); return null; }                                         // Exit after saving status
                FixMessageList:sendFixedMessage(c, "3" , "");                                               // Send message to redo

			} else {
                /* Inform the client that the answer is incorrect and move on to next. */
				if (pT.informNext == 1) {

                    sStatusUpdateStr = "32";                                                                // 32 = Informed correct answer + Next question
                    fUpdateOutgoingIncomingSMS(c, oS, iS, sStatusUpdateStr, 1);  

                    if(endOnJump==1){ fResetCSMSP(cSMS); return null; }                                     // Exit after saving status                    

                    FixMessageList:sendFixedMessage(c, "5" , m.informCorrectText);                          // Send message with correct answer
                    PatternList:sendNextSMS(c, p, pmtns);                                                   // Send next message in flow

                    } else {
                        
                        /* Just move on to next. */

                        sStatusUpdateStr = "33";                                                            // 33 = Incorrect answer + Next question
                        fUpdateOutgoingIncomingSMS(c, oS, iS, sStatusUpdateStr, 1);  

                        if(endOnJump==1){ fResetCSMSP(cSMS); return null; }                                 // Exit after saving status
                        PatternList:sendNextSMS(c, p, pmtns);                                               // Send next message in flow
                        
    				}
			}		
		}
	} else { 
		FixMessageList:sendFixedMessage(c, "2", iMaxMMC);
	}	
}

/* ********************************************************** */
/* ********************************************************** */

    string fGetPatternMessageTextNext(int ci, string ca, Pattern p){

        if(ca==null){ ca = ""; }
        if(ci==null){ ci = 0; }

        //string ls = String:concat("fGetPatternMessageTextNext...", ci," : ", ca); Mez:log(ls);

        string[] cas = String:split(ca, ";"); int maxi = cas.length();
        if(String:lower(ca) == "endactivity") {
            ca = "endactivity";
        } else if( (ci <= -1) || ((ci+1) >= maxi) ){
            ca = "";
        } else {
            ca = cas.get(ci+1);
            if(bIsValidOptionPMT(ca, p)==false){ ca = ""; }
        }
        return ca;
        
    }

    /* ****************************************************** */

    bool bIsValidOptionPMT(string pmtext, Pattern p){
        bool breturn = false; Message[] ms; Message m; PatternMessageText[] pmtns; string slog; if(pmtext==null){ pmtext=""; }
        
        ms = Message:equals(_MTID, pmtext);
        if(ms.length()>0){
            m = ms.get(0);
            pmtns = PatternMessageText:and(relationshipIn(patternMessageTextID_pattern, p), relationshipIn(patternMessageText_Message, m));
            if(pmtns.length()>0){
                breturn = true;
            }
        }

        slog = String:concat("bIsValidOptionPMT... incoming : '", pmtext, "' and matching status : '", breturn, "'"); Mez:log(slog); 
        return breturn;
    }

    /* ****************************************************** */

    int fGetMatchingAnswer(string icsms, string ca){

        if(icsms==null){ icsms = ""; }
        if(ca==null){ ca = ""; }

        //string ls = String:concat("fGetMatchingAnswer...", icsms," : ", ca); Mez:log(ls);
        int i; int maxi; int ri = -2; if(ca==null){ca = "";}
        string[] cas = String:split(ca, ";"); maxi = cas.length();
        
        if(maxi>1){
            for(i = 0; i<maxi; i++){
                ca = cas.get(i);
                if(String:lower(icsms) == String:lower(ca)){return i;}
            }
        } else {
            if(String:lower(icsms) == String:lower(ca)){ri = -1;}
            if(String:lower(ca) == "endactivity"){ri = -1;}
            return ri;
        }
        
    }

/* ********************************************************** */
/* ********************************************************** */

void fResetCSMSP(CurrentSMSPattern cSMS){
    cSMS.active = 0; cSMS.save();
}

/* ********************************************************** */
/* ********************************************************** */

OutgoingSMSLog[] fGetAllMatchingOutgoingSMSLog(Client c, Umbrella u, Topic t, Pattern p, Message m, int code) {
    
    if (c==null) { return null; }

    OutgoingSMSLog[] osls;

    if((u!=null&&t!=null&&p!=null&&m!=null)||(code==1)) {
        osls = OutgoingSMSLog:and(relationshipIn(client_outgoingSMSLog,c),relationshipIn(umbrella_outgoingSMSLog,u),relationshipIn(topic_outgoingSMSLog,t),relationshipIn(pattern_outgoingSMSLog,p),relationshipIn(message_outgoingSMSLog,m),notEquals(validFirstLetter,"0"));    
    }else if (u!=null&&t!=null&&p!=null) {
        osls = OutgoingSMSLog:and(relationshipIn(client_outgoingSMSLog,c),relationshipIn(umbrella_outgoingSMSLog,u),relationshipIn(topic_outgoingSMSLog,t),relationshipIn(pattern_outgoingSMSLog,p),notEquals(validFirstLetter,"0"));
    } else if (u!=null&&t==null) {
        osls = OutgoingSMSLog:and(relationshipIn(client_outgoingSMSLog,c),relationshipIn(umbrella_outgoingSMSLog,u),notEquals(validFirstLetter,"0"));
    } else if (t!=null) {
        osls = OutgoingSMSLog:and(relationshipIn(client_outgoingSMSLog,c),relationshipIn(topic_outgoingSMSLog,t),notEquals(validFirstLetter,"0"));
    }
    
    return osls;
}


/* ********************************************************** */
/* ********************************************************** */

void fUpdateExistingOutgoingSMSLog(Client c, Umbrella u, Topic t, Pattern p, Message m){

    // Checks for a previous outgoingSMS for same Client, Umbrella, Topic, Pattern and Message... and sets validFirstLetter to "0"
    // This response will then be saved, but ignored for future calculations and reporting

    OutgoingSMSLog[] osls = fGetAllMatchingOutgoingSMSLog(c, u, t, p, m, 1);
    OutgoingSMSLog osl; int i;
    if(osls.length()>0){
        for(i=osls.length()-1; i>=0; i--){
            osl = osls.get(i);
            osl.validFirstLetter = "0";
        }
    }
}

/* ********************************************************** */
/* ********************************************************** */

void fSaveOutgoingSMSLog(Client c, OutgoingSMS og, IncomingSMS ic){

    if(c==null||og==null||ic==null){ return null; }

    Umbrella u = uGetCurrentSchedule:fGetCurrentUmbrella(c);
    Topic t = uGetCurrentSchedule:fGetCurrentTopic(c);
    Pattern p = og.outgoingSMS_pattern;
    Message m = og.outgoingSMS_Message;

    if(t==null||p==null||m==null){ return null; }

    fUpdateExistingOutgoingSMSLog(c, u, t, p, m);

    OutgoingSMSLog osl = OutgoingSMSLog:new();

    osl.messageText = og.messageText;
    osl.validFirstLetter = og.validFirstLetter;
    osl.maxMultipleChoice = og.maxMultipleChoice;
    osl.correctAnswer = og.correctAnswer;
    osl.dateTimeStamp = og.dateTimeStamp;
    osl.responseText = og.responseText;
    osl.status = og.status;
    osl.userScore = og.userScore;
    
    osl.client_outgoingSMSLog = og.outgoingSMS_client;
    osl.pattern_outgoingSMSLog = og.outgoingSMS_pattern; 
    osl.message_outgoingSMSLog = og.outgoingSMS_Message;

    osl.flags = "";
    osl.incomingsms_outgoingSMSLog = ic;
    osl.umbrella_outgoingSMSLog = u;
    osl.topic_outgoingSMSLog = t;

    osl.save();

}

/* ********************************************************** */
/* ********************************************************** */
