unit MessageOrderController;

string msg;

PatternMessageText createMessageOrder(string patternid, string messageid, int o){
    
    Pattern[] sArr = Pattern:equals(patternID, patternid);
    Message[] mArr = Message:equals(_MTID, messageid);

    if (sArr.length() != 1){

    	if (sArr.length() > 1){
    		msg = String:concat("There is duplication for the Activity:", patternid);
    		Logger:log(msg);
    		Alerter:alert(msg);
    	} else {
    		msg = String:concat("There was no Activity found for ActivityID: ", patternid);
    		Logger:log(msg);
    		Alerter:alert(msg);
    		return null;
    	}
    }

    if (mArr.length() != 1){

    	if (sArr.length() > 1){
    		msg = String:concat("There is duplication for the Message:", messageid);
    		Logger:log(msg);
    		Alerter:alert(msg);
    	} else {
    		msg = String:concat("There was no Message found for MessageID: ", messageid);
    		Logger:log(msg);
    		Alerter:alert(msg);
    		return null;
    	}
    }

    Pattern a = sArr.get(0);
    Message m = mArr.get(0);
    PatternMessageText[] check = PatternMessageText:and(relationshipIn(patternMessageTextID_pattern, a),relationshipIn(patternMessageText_Message,m)); 
    if(check.length()>0) { 
    	msg = String:concat("MessageOrder not saved the Activity:", a.patternID, " and the Message: ", m._MTID, " are already associated");
        Logger:log(msg);
        Alerter:alert(msg);
        return null;
    }

    PatternMessageText pmt = PatternMessageText:new();
    pmt.patternMessageTextID_pattern = a;
    pmt.patternMessageText_Message = m;
    pmt._MTID_order = o;
    pmt.save();

    msg = String:concat("MessageOrder saved with Activity:", a.patternID, " and Message: ", m._MTID);
    Logger:log(msg);
    Alerter:alert(msg);

    return pmt;
}


PatternMessageText[] getAllMassageOrders() {
 	return PatternMessageText:all();
}

PatternMessageText[] getMassageOrdersForMessage(Message m){
    return PatternMessageText:relationshipIn(patternMessageText_Message, m);
}

PatternMessageText[] getMassageOrdersForActivity(Pattern p) {
	PatternMessageText[] arr;
	if (p == null){
		arr = getAllMassageOrders();
	} else {
		arr = PatternMessageText:relationshipIn(patternMessageTextID_pattern, p);
	}
  	return arr;
}

PatternMessageText getMessageOrderForMessageOrderTemp(MessageOrderTemp messageOrderTemp){
	PatternMessageText[] messageOrders;

	if (messageOrderTemp == null){
		return null;
	}

	Message o_message = MessageController:getMessageForMessageID(messageOrderTemp.message_id);
	int messageOrder = messageOrderTemp.message_order;

	messageOrders = PatternMessageText:and(
		relationshipIn(patternMessageText_Message, o_message), 
		equals(_MTID_order, messageOrder)
	);

	if (messageOrders.length() < 1){
		return null;
	}

    if (messageOrders.length() > 1){
        string msg = String:concat("WARNING: There is a duplication with for MessageID=", messageOrderTemp.message_id);
        Logger:log(msg);
        Alerter:alert(msg);
    }

	return messageOrders.get(0);
}

int getMessageOrderForMessageActivity(Message m, Pattern a){
	
	PatternMessageText[] arr;
	PatternMessageText messageOrder;

	if (m == null || a == null){
		return 0;
	}

	arr = PatternMessageText:and(
		relationshipIn(patternMessageText_Message, m),
		relationshipIn(patternMessageTextID_pattern, a)
	);

	if (arr == null){
		return 0;
	}

	if (arr.length() < 1){
		return 0;
	}

    if (arr.length() > 1){
        string msg = String:concat("WARNING: There is a duplication in a MessageOrder for MessageID=", m._MTID, " ActivityID=", a.patternID);
        Logger:log(msg);
        Alerter:alert(msg);
    }

	messageOrder = arr.get(0);

	if (messageOrder == null){
		return 0;
	}

	return messageOrder._MTID_order;

}

bool isMessagewOrderAssignedToActivity(Pattern a, int orderNumber){

    PatternMessageText[] arr;

    if (a == null || orderNumber == null){
        return false;
    }

    arr = PatternMessageText:and(
        relationshipIn(patternMessageTextID_pattern, a),
        equals(_MTID_order, orderNumber)
    );

    if (arr.length() <= 0){
        return false;
    }

    return true;

}



